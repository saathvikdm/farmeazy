"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findPackageDependencyDir = exports.findPackageDir = exports.findPackage = exports.writePackage = exports.readPackage = exports.isPackageManifest = exports.getMangledPackageName = exports.parsePackageRef = void 0;
const properties_1 = require("@rnx-kit/tools-language/properties");
const find_up_1 = __importDefault(require("find-up"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const pkg_dir_1 = __importDefault(require("pkg-dir"));
const pkg_up_1 = __importDefault(require("pkg-up"));
/**
 * Parse a package reference string. An example reference is the `name`
 * property found in `package.json`.
 *
 * @param r Package reference string
 * @returns Parsed package reference object
 */
function parsePackageRef(r) {
    if (r.startsWith("@")) {
        const indexSeparator = r.indexOf("/");
        // The separator must start from position >= 2 to ensure that it is '@'
        // and at least one other character. Further, the separator must have
        // at least 1 character following it, before the end of the string.
        if (indexSeparator < 2 || indexSeparator + 2 >= r.length) {
            throw new Error(`Invalid package reference: "${r}"`);
        }
        return {
            scope: r.substring(0, indexSeparator),
            name: r.substring(indexSeparator + 1),
        };
    }
    if (!r) {
        throw new Error(`Invalid package reference: "${r}"`);
    }
    return { name: r };
}
exports.parsePackageRef = parsePackageRef;
/**
 * Get the mangled name for a package reference.
 *
 * @param ref Package reference
 * @returns Mangled name
 */
function getMangledPackageName(ref) {
    if (ref.scope) {
        return ref.scope.slice(1) + "__" + ref.name;
    }
    return ref.name;
}
exports.getMangledPackageName = getMangledPackageName;
/**
 * Determine if the given object is a `package.json` manifest.
 *
 * @param manifest Object to evaluate
 * @returns `true` if the object is a manifest
 */
function isPackageManifest(manifest) {
    return (typeof manifest === "object" &&
        manifest !== null &&
        "name" in manifest &&
        "version" in manifest);
}
exports.isPackageManifest = isPackageManifest;
/**
 * Resolve a package path to a file reference by appending `package.json`, if needed.
 *
 * @param pkgPath Package path. May contain `package.json`.
 * @returns File reference to `package.json`
 */
function resolvePackagePath(pkgPath) {
    if (path_1.default.basename(pkgPath).toLowerCase() !== "package.json") {
        return path_1.default.join(pkgPath, "package.json");
    }
    return pkgPath;
}
/**
 * Read a `package.json` manifest from a file.
 *
 * @param pkgPath Either a path directly to the target `package.json` file, or the directory containing it.
 * @returns Package manifest
 */
function readPackage(pkgPath) {
    const pkgFile = resolvePackagePath(pkgPath);
    return JSON.parse(fs_1.default.readFileSync(pkgFile, "utf-8"));
}
exports.readPackage = readPackage;
/**
 * Write a `package.json` manifest to a file.
 *
 * @param pkgPath Either a path directly to the target `package.json` file, or the directory containing it.
 * @param manifest Package manifest
 * @param space Indentation to apply to the output
 */
function writePackage(pkgPath, manifest, space = "  ") {
    const pkgFile = resolvePackagePath(pkgPath);
    fs_1.default.writeFileSync(pkgFile, JSON.stringify(manifest, undefined, space) + "\n", "utf-8");
}
exports.writePackage = writePackage;
/**
 * Find the nearest `package.json` manifest file. Search upward through all
 * parent directories.
 *
 * If a starting directory is given, use it. Otherwise, use the current working
 * directory.
 *
 * @param startDir Optional starting directory for the search. If not given, the current directory is used.
 * @returns Path to `package.json`, or `undefined` if not found.
 */
function findPackage(startDir) {
    var _a;
    return (_a = pkg_up_1.default.sync({ cwd: startDir ? startDir : process.cwd() })) !== null && _a !== void 0 ? _a : undefined;
}
exports.findPackage = findPackage;
/**
 * Find the parent directory of the nearest `package.json` manifest file. Search
 * upward through all parent directories.
 *
 * If a starting directory is given, use it. Otherwise, use the current working
 * directory.
 *
 * @param startDir Optional starting directory for the search. If not given, the current directory is used.
 * @returns Path to `package.json`, or `undefined` if not found.
 */
function findPackageDir(startDir) {
    var _a;
    return (_a = pkg_dir_1.default.sync(startDir ? startDir : process.cwd())) !== null && _a !== void 0 ? _a : undefined;
}
exports.findPackageDir = findPackageDir;
/**
 * Find the package dependency's directory, starting from the given directory
 * and moving outward, through all parent directories.
 *
 * Package dependencies exist under 'node_modules/[`scope`]/[`name`]'.
 *
 * @param ref Package dependency reference
 * @param options Options which control the search
 * @returns Path to the package dependency's directory, or `undefined` if not found.
 */
function findPackageDependencyDir(ref, options) {
    var _a;
    const pkgName = typeof ref === "string" ? ref : path_1.default.join((_a = ref.scope) !== null && _a !== void 0 ? _a : "", ref.name);
    return find_up_1.default.sync(path_1.default.join("node_modules", pkgName), Object.assign(Object.assign({}, (0, properties_1.pickValues)(options !== null && options !== void 0 ? options : {}, ["startDir", "allowSymlinks"], ["cwd", "allowSymlinks"])), { type: "directory" }));
}
exports.findPackageDependencyDir = findPackageDependencyDir;
//# sourceMappingURL=package.js.map