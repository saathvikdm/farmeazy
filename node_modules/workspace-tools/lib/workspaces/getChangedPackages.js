"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChangedPackages = void 0;
const git_1 = require("../git");
const getWorkspaces_1 = require("./getWorkspaces");
const multimatch_1 = __importDefault(require("multimatch"));
const path_1 = __importDefault(require("path"));
/**
 * Finds all packages that had been changed in the repo under cwd
 *
 * executes a "git diff $Target..." to get changes given a merge-base
 *
 * further explanation with the three dots:
 *
 * > git diff [--options] <commit>...<commit> [--] [<path>...]
 * >
 * >    This form is to view the changes on the branch containing and up to
 * >    the second <commit>, starting at a common ancestor of both
 * >    <commit>. "git diff A...B" is equivalent to "git diff
 * >    $(git-merge-base A B) B". You can omit any one of <commit>, which
 * >    has the same effect as using HEAD instead.
 *
 * @returns string[] of package names that have changed
 */
function getChangedPackages(cwd, target, ignoreGlobs = []) {
    const workspaceInfo = (0, getWorkspaces_1.getWorkspaces)(cwd);
    target = target || (0, git_1.getDefaultRemoteBranch)(undefined, cwd);
    let changes = [
        ...new Set([
            ...((0, git_1.getUntrackedChanges)(cwd) || []),
            ...((0, git_1.getUnstagedChanges)(cwd) || []),
            ...((0, git_1.getBranchChanges)(target, cwd) || []),
            ...((0, git_1.getStagedChanges)(cwd) || []),
        ]),
    ];
    const ignoreSet = new Set((0, multimatch_1.default)(changes, ignoreGlobs));
    changes = changes.filter((change) => !ignoreSet.has(change));
    const changeSet = new Set();
    for (const change of changes) {
        const candidates = workspaceInfo.filter((pkgPath) => change.indexOf(path_1.default.relative(cwd, pkgPath.path).replace(/\\/g, "/")) ===
            0);
        if (candidates && candidates.length > 0) {
            const found = candidates.reduce((found, item) => {
                return found.path.length > item.path.length ? found : item;
            }, candidates[0]);
            changeSet.add(found.name);
        }
        else {
            return workspaceInfo.map((pkg) => pkg.name);
        }
    }
    return [...changeSet];
}
exports.getChangedPackages = getChangedPackages;
